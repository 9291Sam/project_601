==> ./@ballbot/static_state_feedback.m <==
function [x] = static_state_feedback(sys,t,x0,K,xtilde,utilde)

u = @(x) utilde - K*(x - xtilde);

[~,x] = ode45(@(t,x) sys.dynamics(x,u(x)),t,x0);

end
==> ./@ballbot/linearize.m <==
function [A, B] = linearize(sys,x,u)
    zero_x = zeros(size(x));
    zero_u = zeros(size(u));
    if (isequal(zero_x(3:end), x(3:end)) && isequal(zero_u, u))
        A = get_A_matrix(sys.r, sys.d, sys.m_ball, sys.m_body, sys.I_ball, sys.I_body_xy, sys.I_body_z, sys.g);
        B = get_B_matrix(sys.r, sys.d, sys.m_ball, sys.m_body, sys.I_ball, sys.I_body_xy, sys.I_body_z, sys.g);
    else
        x
        u
        error("Can't linearize around given x and u!");
    end

end
==> ./@ballbot/dynamics.m <==
function dx = dynamics(sys, state, input)

if nargin < 2
    state = zeros(sys.num_states,1);
end
if nargin < 3
    input = zeros(sys.num_inputs,1);
end

    new_states = ballbot_dynamics(...
        state(1), state(2), state(3), state(4), state(5), state(6), state(7), state(8),...
        input(1), input(2),...
        sys.r, sys.d, sys.m_ball, sys.m_body, sys.I_ball, sys.I_body_xy, sys.I_body_z, sys.g...
    );

    dx = [state(5:8); new_states];
end
==> ./@ballbot/draw.m <==
function draw(sys, x)
    f = figure("Position", [100, 100, 1920, 1620]);
    clf;

    grid on;
    hold on;
    axis equal;
    axis([-4 4 -4 4 0 4]); 
    axis manual; 
    axis vis3d;

    view(3);            
    xlabel('X'); ylabel('Y'); zlabel('Z');
    plot3(0, 0, 0, 'kx', 'MarkerSize', 15, 'LineWidth', 2); % root marker

    ball_radius = sys.r;
    body_length = sys.d * 2;

    ballbot_root_transform = hgtransform; 
    body_transform = hgtransform('Parent', ballbot_root_transform);


    % Ball geometry
    [sx, sy, sz] = sphere(20);
    sx = sx * ball_radius;
    sy = sy * ball_radius;
    sz = sz * ball_radius;
    surf(sx, sy, sz, 'Parent', ballbot_root_transform, 'FaceColor', [0.8 0.8 0.8], 'EdgeColor', [0.5 0.5 0.5]);

    % Body geometryã€€% TODO: should this be a cylinder
    plot3([0, 0], [0, 0], [0, body_length], 'LineWidth', 6, 'Color', 'r', 'Parent', body_transform);

    for k = 1:size(x,1)
        x_pos = x(k, 1);
        y_pos = x(k, 2);
        theta = x(k, 3); 
        phi   = x(k, 4);         
        
        T_translate = makehgtform('translate', [x_pos, y_pos, ball_radius]);
        set(ballbot_root_transform, 'Matrix', T_translate);
        
        T_pitch = makehgtform('yrotate', theta);
        T_roll  = makehgtform('xrotate', phi);
        
        set(body_transform, 'Matrix', T_pitch * T_roll);
        
        drawnow; 
        
        pause(1/60); 
    end
end
==> ./@ballbot/simulate.m <==
function [x] = simulate(sys,t,x0)

[~,x] = ode45(@(t,x) sys.dynamics(x),t,x0);

end
==> ./@ballbot/observed_trajectory_tracked.m <==
function x = observed_trajectory_tracked(sys, t_span, x0, K, r, L, C, D)

plant = @(x, u) sys.dynamics(x, u);

observer = @(xhat, y, u) sys.dynamics(xhat, u) - L*(y-C*xhat-D*u);

output = @(x, u) C*x+D*u;

controller = @(t, x) -K*(x - r(t));


    global counter;


function f = full_dynamics(plant, observer, controller, output, x, xhat, t)

    counter = counter + 1
    disp("dynamics");

u = controller(t, xhat);
y = output(x, u);

f = [ plant(x,u); observer(xhat,y,u) ];

end

[~, x] = ode45(@(t, x) full_dynamics(plant, observer, controller, output, x(1:8), x(9:16), t), t_span, x0);

end
==> ./@ballbot/ballbot.m <==
classdef ballbot
    % A Ballbot is an 8-dimension nonlinear system with state
    % [x; y; theta; phi; dx; dy; dtheta; dphi]
    % where
    % x - cartesian position of the contact point of the base of the ball
    % y - cartesian position of the contact point of the base of the ball
    % theta - rotation around the global y axis. +theta leans towards +X
    % phi   - rotation around the global z axis. +phi leans towards -Y

    % with constants
    % r         - ball radius
    % d         - distance between ball com & body com
    % m_ball    - mass of the ball
    % m_body    - mass of the body
    % I_ball    - moment of inertia of the ball (spherically symmetrical)
    % I_body_xy - moment of inertia of the body around the x&y axis
    % I_body_z  - moment of inertia of the body around the z axis
    % g         - gravitational constant

    properties
        num_states
        num_inputs
        r       
        d       
        m_ball  
        m_body  
        I_ball  
        I_body_xy
        I_body_z
        g       
    end

    methods
        function obj = ballbot()
            obj.num_states = 8;
            obj.num_inputs = 2;

            obj.r = 0.1;
            obj.d = 0.5;
            obj.m_ball = 2.0;
            obj.m_body = 10.0;
            obj.I_ball = (2/5) * obj.m_ball * obj.r^2;
            radius_body = obj.r * 1.25;
            length_body = obj.d * 2;
            obj.I_body_xy = (1/4) * obj.m_body * radius_body^2 + (1/12) * obj.m_body * length_body^2;
            obj.I_body_z = (1/2) * obj.m_body * radius_body^2;
            obj.g = 10;
        end
    end
end
==> ./@ballbot/trajectory_tracked_static_state_feedback.m <==
function [x] = trajectory_tracked_static_state_feedback(sys,t_span,x0,K,r)

    u = @(t, x) -K*(x - r(t));

    [~,x] = ode45(@(t,x) sys.dynamics(x,u(t, x)),t_span,x0);

end