==> ./@unicycle/simulate_no_input.m <==
function [x] = simulate_no_input(sys, t, x0)

[~, x] = ode45(@(t, x) sys.dynamics_no_input(x), t, x0);


end
==> ./@unicycle/draw.m <==
function draw(sys, x)

f = figure();
clf;

grid on;
hold on;
axis equal;
axis([-8 8 -8 8 0 8]); 
axis manual; 
axis vis3d;

view(3);            
xlabel('X'); ylabel('Y'); zlabel('Z');
plot3(0, 0, 0, 'kx', 'MarkerSize', 15, 'LineWidth', 2);



wheel_center_seat_distance = sys.d;
wheel_radius = sys.r;
wheel_width = 0.25;

unicycle_root_transform = hgtransform; 

% Seat Line
seat_transform = hgtransform('Parent', unicycle_root_transform);
plot3([0, 0], [0, 0], [0, wheel_center_seat_distance], 'LineWidth', 4, 'Color', 'r', 'Parent', seat_transform);

% Wheel
wheel_transform = hgtransform('Parent', unicycle_root_transform);
wheel_xrotated_pi2 = hgtransform('Parent', wheel_transform);
set(wheel_xrotated_pi2, 'Matrix', makehgtform('xrotate', pi/2));
[xc, yc, zc] = cylinder(wheel_radius, 30);
zc = zc * wheel_width - (wheel_width/2);
surf(xc, yc, zc, 'Parent', wheel_xrotated_pi2, 'FaceColor', [0.2 0.2 0.2], 'EdgeColor', 'none'); 
% Wheel Spoke
plot3([0 0], [0 wheel_radius], [0 0], 'LineWidth', 3, 'Color', 'b', 'Parent', wheel_xrotated_pi2);


last_valid_k = 1;

for k = 1:size(x,1)

    % if (abs(x(k, 4)) < pi/2 && abs(x(k, 6)) < pi/2)
        last_valid_k = k;
    % end


    % rendering
    x_pos = x(last_valid_k, 1);
    y = x(last_valid_k, 2);
    theta = x(last_valid_k, 3); % tangent to a circle
    phi = x(last_valid_k, 4);
    Omega = x(last_valid_k, 5);
    alpha = x(last_valid_k, 6);
    
    T_pos  = makehgtform('translate', [x_pos, y, wheel_radius * cos(phi)]);
    T_yaw  = makehgtform('zrotate', theta);
    T_lean = makehgtform('xrotate', phi);
    
    % Handles x, y, theta, and phi
    set(unicycle_root_transform, 'Matrix', T_pos * T_yaw * T_lean);
    
    set(wheel_transform, 'Matrix', makehgtform('yrotate', Omega));

    set(seat_transform, 'Matrix',  makehgtform('yrotate', alpha))
    
    disp("rendering state");
    x(k, :)
    drawnow; pause(1/30)
end



end
==> ./@unicycle/eom_deriver.m <==
function eom_deriver()
% https://github.com/MatthewPeterKelly/Lagrange_Mechanics_Derivations
% https://github.com/MatthewPeterKelly/Lagrange_Mechanics_Derivations/blob/28680024833fe3dd00af9d1ec23644b6f3d4de87/springCartPole/EoM_Spring_Cart_Pole.m

syms x y theta phi Omega 'real';
alpha = sym('alpha', 'real');
syms dotx doty dottheta dotphi dotOmega dotalpha 'real';
syms ddotx ddoty ddottheta ddotphi ddotOmega ddotalpha 'real';

q  = [x; y; theta; phi; Omega; alpha];
dq = [dotx; doty; dottheta; dotphi; dotOmega; dotalpha];
ddq = [ddotx; ddoty; ddottheta; ddotphi; ddotOmega; ddotalpha];

% t_1 - wheel pitch
% t_2 - seat roll
% t_3 - seat pitch
syms t_1 t_2 t_3 'real';


% r          - wheel radius
% d          - distance between fork and hub
% m_w        - wheel mass
% m_s        - seat mass
% I_wpitch   - Wheel pitch moment
% I_wyawroll - Wheel roll moment
% g          - gravitational constant
syms r d m_w m_s I_wpitch I_wyawroll g 'real'; 

local_wheel_inertias = [I_wyawroll 0 0; 0 I_wpitch 0; 0 0 I_wyawroll];

% Order of rotations. 
% {alpha / omega} -> phi -> theta -> world

% these matrices bring things into global space from the local spaces
Rz_theta = [
    cos(theta) -sin(theta) 0; 
    sin(theta) cos(theta)  0;
    0          0           1
];

rotate_by_theta = Rz_theta;

Rx_phi = [
    1 0        0;
    0 cos(phi) -sin(phi);
    0 sin(phi) cos(phi);
];

rotate_by_phi = Rx_phi;

Ry_alpha = [
    cos(alpha)  0 sin(alpha);
    0           1 0;
    -sin(alpha) 0 cos(alpha);
];

rotate_by_alpha = Ry_alpha;

% global origin -> unicycle_base
root = [x; y; 0];

% vector between global origin -> wheel center
wheel_hub_global_pos = root + rotate_by_theta * rotate_by_phi * [0; 0; r];
% global origin -> seat center
seat_global_pos = wheel_hub_global_pos + rotate_by_theta * rotate_by_phi * rotate_by_alpha * [0; 0; d];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% lagrangian shit

% time derivative & chain rule 
% jacobian(wheel_hub_global_pos, q): 
wheel_hub_global_velocity = jacobian(wheel_hub_global_pos, q) * dq;
seat_global_velocity      = jacobian(seat_global_pos, q) * dq;

% T = 0.5 m v^2
T_wheel_translation = 0.5 * m_w * (wheel_hub_global_velocity.'*wheel_hub_global_velocity);
T_seat_translation = 0.5 * m_s * (seat_global_velocity.'*seat_global_velocity);




% bring rotations into global space, then put them in the frame of the wheel
wheel_yaw_world = [0; 0; dottheta];
wheel_roll_world = Rz_theta * [dotphi; 0; 0];
wheel_pitch_world = Rz_theta * Rx_phi * [0; dotOmega; 0];
wheel_rotations_world = wheel_yaw_world + wheel_roll_world + wheel_pitch_world;
global_rotations_to_wheel_local_rotations = (rotate_by_theta * rotate_by_phi).';
wheel_rotations_local = global_rotations_to_wheel_local_rotations * wheel_rotations_world;

% 0.5 * w' J w
T_wheel_rotation = 0.5 * wheel_rotations_local.' * local_wheel_inertias * wheel_rotations_local;


U_wheel = m_w * g * wheel_hub_global_pos(3);
U_seat = m_s * g * seat_global_pos(3);



T = T_wheel_translation + T_seat_translation + T_wheel_rotation;
U = U_wheel + U_seat;
L = simplify(T - U);


% Everything below is stolen straight from 
% https://github.com/MatthewPeterKelly/Lagrange_Mechanics_Derivations/blob/28680024833fe3dd00af9d1ec23644b6f3d4de87/springCartPole/EoM_Spring_Cart_Pole.m
% Lagrangian
% âˆ‚ = p
% (d/dt)(pL/pdq) - (pL/pq) = generalized forces

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
%                  evaluate partial derivatives                           %
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%

%              DL  
%  DL_Dq  ==  ---      Note that 'D' is partial derivative here 
%              Dq
%
DL_Dq = jacobian(L,q)';

%              DL  
%  DL_Ddq  ==  ---      Note that 'D' is partial derivative here 
%              Ddq
%
DL_Ddq = jacobian(L,dq)';

%                D  / DL  \         * Note that some of those 'd' should be
% DDL_DtDdq  ==  -- | --  |         curvy 'D' to represent partial
%                Dt \ Ddq /         derivatives
%
% Note the application of the chain rule:  (Quoting Andy Ruina: )
%      d BLAH / dt  =  jacobian(BLAH, [q qdot])*[qdot qddot]'
%
DDL_DtDdq = jacobian(DL_Ddq,[q; dq]) * [dq; ddq];


%Write out as single equation and simplify:
EoM = DDL_DtDdq - DL_Dq; % TODO: why was this flipped in the example??
EoM = simplify(EoM); 

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%
%                   mass matrix gymnastics                                %
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%

% This is a confusing step - read carefully:
%
% We know that our equations are of the form:
%             EoM = M(q,dq)*qdd + f(q,dq) == 0;
%
% Thus, we can find M(q,dq) by using the jacobian command:

M = jacobian(EoM,ddq);

% Now, we want to find f(q,dq). We can do this by substituting in zero for
% the acceleration vector (dqq)

f = subs(EoM,ddq,sym([0; 0; 0; 0; 0; 0]));

% https://www.mathworks.com/help/symbolic/sym.matlabfunction.html
matlabFunction(M, "File", "getMassMatrix", "Vars", [q; dq; r; d; m_w; m_s; I_wpitch; I_wyawroll; g]);
matlabFunction(f, "File", "getFVector", "Vars", [q; dq; r; d; m_w; m_s; I_wpitch; I_wyawroll; g]);

% when simulating, n
% EoM = M(q,dq)*qdd + f(q,dq) == 0;
%  M(q,dq)*qdd == -f(q,dq);
% qdd = M(q, dq)^-1 * -f(q, dq)

% assuming input vector is a column vector [t_1; t_2; t_3]
B = [
    0 0 0;
    0 0 0;
    0 0 0;
    0 1 0;
    1 0 0;
    0 0 1;
];
matlabFunction(B, "File", "getInputMatrix",  "Vars", [q; dq; r; d; m_w; m_s; I_wpitch; I_wyawroll; g]);

% inputs
% EoM = M(q,dq)*qdd + f(q,dq) == 0;
% EoM = M(q,dq)*qdd + f(q,dq) == sum Q; (601 document) 
% each tau is a vector 
% Q = 

% t_1 - torque on the wheel (pitch)
% t_2 - torque on the seat (pitch)
% t_3 - torque on the seat (roll)
%https://farside.ph.utexas.edu/teaching/336k/Newton/node90.html

% fuck ass constraints
% dotx * sin(theta) - doty cos(theta) = 0
% dotx * cos(theta) + doty sin(theta) = r * dotOmega


%M(q, dq)ddq + f(q, dq) = Bu

% row vectors because constraint * dq == 0
lateral_constraint = [sin(theta), -cos(theta), 0, 0, 0, 0];
rolling_constraint = [cos(theta), sin(theta), 0, 0, -r, 0];

C = [
    lateral_constraint;
    rolling_constraint
];
% C * dq == 0
C_eq0 = C * dq;
time_derivative_c_eq0 = jacobian(C_eq0, [q; dq]) * [dq; ddq];
gamma = subs(time_derivative_c_eq0, ddq, [0; 0; 0; 0; 0; 0]);

matlabFunction(C, "File", "getConstraintMatrix", "Vars", [q; dq; r; d; m_w; m_s; I_wpitch; I_wyawroll; g]);
matlabFunction(gamma, "File", "getConstraintGamma", "Vars", [q; dq; r; d; m_w; m_s; I_wpitch; I_wyawroll; g]);

end



==> ./@unicycle/dynamics_no_input.m <==
function dx = dynamics_no_input(sys, x)




% when simulating, n
% EoM = M(q,dq)*qdd + f(q,dq) == 0;
%  M(q,dq)*qdd == -f(q,dq);
% qdd = M(q, dq)^-1 * -f(q, dq)


M = getMassMatrix(x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8), x(9), x(10), x(11), x(12), sys.r, sys.d, sys.m_w, sys.m_s, sys.I_wpitch, sys.I_wyawroll, sys.g);
f = getFVector(x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8), x(9), x(10), x(11), x(12), sys.r, sys.d, sys.m_w, sys.m_s, sys.I_wpitch, sys.I_wyawroll, sys.g);
% B = getInputMatrix(x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8), x(9), x(10), x(11), x(12), sys.r, sys.d, sys.m_w, sys.m_s, sys.I_wpitch, sys.I_wyawroll, sys.g);
C = getConstraintMatrix(x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8), x(9), x(10), x(11), x(12), sys.r, sys.d, sys.m_w, sys.m_s, sys.I_wpitch, sys.I_wyawroll, sys.g);
gamma = getConstraintGamma(x(1), x(2), x(3), x(4), x(5), x(6), x(7), x(8), x(9), x(10), x(11), x(12), sys.r, sys.d, sys.m_w, sys.m_s, sys.I_wpitch, sys.I_wyawroll, sys.g);

[n_constraints, ~] = size(C);

left = [M, -C'; C, zeros(n_constraints)];
right = [-f; -gamma];

numerical_solution = left \ right; % might be the dumbest operator in existance

dx(1:6) = x(7:12);
dx(7:12) = numerical_solution(1:6);

dx = dx';

end
==> ./@unicycle/unicycle.m <==
classdef unicycle
    % The unicycle is a 12-dimensional nonlinear system with state
    % [x; y; theta; phi; Omega; alpha; dotx; doty; dottheta; dotphi; omega; dotalpha]
    % where:
    %   x - Cartesian coordinate of the contact point of the unicycle's wheel to the ground
    %   y - Cartesian coordinate of the contact point of the unicycle's wheel to the ground
    %   theta - Angle between the unicycle's forward (+x) vector and the global (+x) vector
    %   phi - Angle between the unicycle's vertical (+z) vector and the global
    %   Omega - Angle spun by the wheel
    %   alpha - Angle of the fork

    % Order of Rotations
    % {alpha, Omega} -> phi -> theta

    properties
        num_states
        num_inputs
        r
        d
        m_w
        m_s
        I_wpitch
        I_wyawroll
        g
    end

    methods
        function obj = unicycle()
            obj.num_states = 12;
            obj.num_inputs = 0;

            obj.r = 0.5;
            obj.d = 1.25;
            obj.m_w = 5.0;
            obj.m_s = 60;
            obj.I_wpitch = 0.5 * obj.m_w * obj.r^2; % TODO: numbers pulled from the ether
            obj.I_wyawroll = 0.25 * obj.m_w * obj.r^2;
            obj.g = 10;

            % eom_deriver();
        end
    end

    methods (Static)
        eom_deriver()
    end
end